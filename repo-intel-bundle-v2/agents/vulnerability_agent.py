import json
import os
import sys
import argparse
from datetime import datetime

def load_json(path):
    with open(path, 'r') as f:
        return json.load(f)

def save_json(path, data):
    with open(path, 'w') as f:
        json.dump(data, f, indent=2, default=str)

def save_markdown(path, content):
    with open(path, 'w') as f:
        f.write(content)

def analyze_vulnerability(repo_data):
    signals = repo_data.get("signals", {})
    scores = repo_data.get("scores", {})
    
    # 1. Calculate Security Posture Score
    # Start with base score 100
    security_score = 100
    risk_level = "Low"
    
    findings = []
    
    # Secrets Check
    if signals.get("has_secrets_smell"):
        security_score -= 30
        findings.append({
            "title": "Secrets Detected in Codebase",
            "severity": "High",
            "description": "Potential hardcoded secrets found.",
            "evidence": signals.get("potential_secrets_found", [])
        })

    # Docker Root User
    docker_issues = signals.get("dockerfile_issues", [])
    if "Runs as root user" in docker_issues:
        security_score -= 15
        findings.append({
            "title": "Container Runs as Root",
            "severity": "Medium",
            "description": "Dockerfile is configured to run as root, increasing attack surface.",
            "evidence": ["Dockerfile"]
        })
        
    # Docker Latest Tag
    if "Uses 'latest' tag" in docker_issues:
        security_score -= 10
        findings.append({
            "title": "Unpinned Container Image",
            "severity": "Medium",
            "description": "Dockerfile uses 'latest' tag, making builds non-deterministic.",
            "evidence": ["Dockerfile"]
        })

    # Missing Lockfile
    if not signals.get("has_lockfile"):
        security_score -= 5
        findings.append({
            "title": "Missing Dependencies Lockfile",
            "severity": "Low",
            "description": "No lockfile found, risking dependency confusion attacks or breaking changes.",
            "evidence": []
        })

    security_score = max(0, security_score)

    # Determine Risk Level
    if security_score < 50: risk_level = "Critical"
    elif security_score < 70: risk_level = "High"
    elif security_score < 90: risk_level = "Medium"
    else: risk_level = "Low"

    # 2. Remediation Plan
    plan = {
        "immediate": [],
        "short_term": [],
        "long_term": []
    }
    
    if signals.get("has_secrets_smell"):
        plan["immediate"].append("Revoke exposed secrets immediately.")
        plan["short_term"].append("Implement git-secrets or similar pre-commit hooks.")
        
    if "Runs as root user" in docker_issues:
        plan["short_term"].append("Update Dockerfile to creating a non-root user.")
        
    if not signals.get("has_lockfile"):
        plan["short_term"].append("Generate lockfile (e.g., pip freeze > requirements.txt or poetry lock).")

    return {
        "agent": "Vulnerability Detective",
        "repo_slug": f"{repo_data['metadata']['owner']}_{repo_data['metadata']['repo']}",
        "timestamp": datetime.now().isoformat(),
        "security_score": security_score,
        "risk_level": risk_level,
        "findings": findings,
        "remediation_plan": plan
    }

def generate_report(data):
    md = []
    md.append(f"# Vulnerability Report: {data['repo_slug']}")
    md.append(f"**Date:** {data['timestamp']}")
    md.append(f"**Security Score:** {data['security_score']}/100 ({data['risk_level']})")
    md.append("")
    
    md.append("## Executive Summary")
    if data['risk_level'] in ["Critical", "High"]:
        md.append("ðŸš¨ **CRITICAL ATTENTION REQUIRED**: This repository has significant security findings that require immediate action.")
    else:
        md.append("âœ… **Status Good**: Security posture is within acceptable limits, though minor improvements are possible.")
    md.append("")

    md.append("## Key Findings")
    if not data['findings']:
        md.append("No major vulnerabilities detected.")
    else:
        for f in data['findings']:
            icon = "ðŸ”´" if f['severity'] == "High" else "MF" if f['severity'] == "Medium" else "ðŸ”µ"
            md.append(f"### {icon} {f['title']} ({f['severity']})")
            md.append(f"{f['description']}")
            if f['evidence']:
                md.append("**Evidence:**")
                for ev in f['evidence']:
                    md.append(f"- `{ev}`")
            md.append("")

    md.append("## Remediation Plan")
    md.append("### Immediate (0-7 Days)")
    for item in data['remediation_plan']['immediate']:
        md.append(f"- [ ] {item}")
    if not data['remediation_plan']['immediate']: md.append("- *None*")

    md.append("### Short Term (2-4 Weeks)")
    for item in data['remediation_plan']['short_term']:
        md.append(f"- [ ] {item}")
        
    md.append("### Long Term (1-3 Months)")
    for item in data['remediation_plan']['long_term']:
        md.append(f"- [ ] {item}")
        
    return "\n".join(md)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("input_file", help="Path to repo analysis JSON")
    parser.add_argument("output_dir", help="Directory to save agent outputs")
    args = parser.parse_args()

    repo_data = load_json(args.input_file)
    result = analyze_vulnerability(repo_data)
    
    # Paths
    slug = result['repo_slug']
    os.makedirs(args.output_dir, exist_ok=True)
    json_path = os.path.join(args.output_dir, f"{slug}.vuln_detective.json")
    md_path = os.path.join(args.output_dir, f"{slug}.vuln_detective.md")
    
    # Save
    save_json(json_path, result)
    save_markdown(md_path, generate_report(result))
    
    print(f"Processed {slug} -> {json_path}")

if __name__ == "__main__":
    main()
